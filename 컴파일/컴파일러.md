## 컴파일러

컴파일러는 고급 언어로 작성된 코드를 컴퓨터가 실행할 수 있는 `기계어`로 `번역`하는 역할을 합니다.

> **기계어**는 0과 1로 이루어진 가장 저수준의 프로그래밍 언어이다.

컴파일러는 소스 코드를 읽고 다음과 같은 동작을 합니다.

1. **토큰 추출(Lexing)**
   소스 코드를 읽고 토큰으로 분리하는 과정으로 변수, 키워드, 연산자 등을 포함합니다.
2. **파싱(Parsing)**
   토큰을 입력받아, 프로그래밍에 규칙에 맞게 구문 트리를 만들어 소스코드가 올바르게 표현됐는지 확인합니다.
3. **중간 코드 생성(Intermediate Representation Code, IR Code)**
   컴파일러가 최종 기계어를 생성하기 전에 소스 코드를 최적화같은 작업을 시행하기 쉽게 변환하는 작업을 중간 코드 생성이라고 합니다.
4. **어셈블리어 생성**
   생성된 중간 코드는 추상 구문 트리(AST)나 사분 코드(Quadruples)와 같이 생겼는데, 이를 어셈블리어로 변환합니다.

> **어셈블리어**는 기계어를 사람이 이해하기 쉽게 표현한 프로그래밍 언어입니다. 명령어를 기호(mnemonic, 니모닉)으로 나타내고 어셈블러를 통해 기계어로 변환됩니다.

**5. 어셈블리**
어셈블러(Assembler)가 생성된 어셈블리 코드를 입력으로 받아 기계어 코드로 번역합니다. 어셈블리 코드의 각 명령어를 해당하는 기계어 명령어로 매핑합니다.
**6. 목적 파일 생성(Generate object file)**
생성된 어셈블리 코드를 사용해 코드를 최적화하고, 최종 단계의 기계어로 변환하여 목적파일을 생성합니다.

> 💡 목적 파일들은 기계어나 혹은 이에 준하는 RTL(Register Transfer Level)과 같은 이진 코드로 이루어져 있다.
> • 이 때, 오브젝트 파일은 기계어 코드는 아니지만, 기계어와 좀 더 가까운 어셈블리 코드(assembly code) 혹은 중간 코드(intermediate code) 등으로 이루어져 있어요. 즉, 아직 기계어 코드가 아닙니다.

```
모든 소스코드가 매번 컴파일은 비효율 -> 필요한 코드면 컴파일 + 변경 없는 코드는 컴파일 x-> 변경 없는 파일을 미리 컴파일 해둠
```

분할 컴파일을 가능하게 한다. 재사용이 가능하게 한다.
w
**7. 링킹(Linking)**
컴파일된 목적 파일과 라이브러리를 결합하여 최종적으로 실행할 수 있는 실행 파일을 생성합니다.

### QnA

- **Q.** CPU에서 사용하는 명령어가 다 달라서 코드를 호환시켜야 하는데, 어떻게 기계어로 변환해야 알맞는 명령어가 생길까?
  **A.** 각 CPU는 고유의 명령어 세트 아키텍처(ISA: Instruction Set Architecture)를 가지고 있다.
  중간 코드를 생성하고 목적 코드로 컴파일되기 전에, 컴파일 타임 직전에 시스템 환경 변수같은 값을 읽어서 타겟 CPU에 맞는 명령어 세트로 목적 코드를 생성한다. (따라서, 목적 코드가 생성되고 나면 해당 CPU에서만 목적 코드를 사용할 수 있다)
  중간 코드(플랫폼 종속적이지 않음) → 목적 파일 (CPU 종속적인 어셈블리 코드를 만듦) → 링커가 이제 기계어로 결합해서 실행파일 만들면 PC에서 실행
