# SSD를 메모리로 사용할 수 없는 이유

1. 메모리 읽기/쓰기와 디스크 읽기/쓰기의 차이

    메모리는 바이트 단위로 주소를 지정하고 디스크는 조각 단위로 주소를 지정한다. 바이트 단위의 주소 지정이 지원되지 않기 때문에 CPU는 SSD에 저장된 데이터에 직접 접근할 수 없다.

2. 가상 메모리의 제한

    32비트 머신에서는 가상 메모리가 최대 4GB이기 때문에 프로세스가 4GB 이상은 사용할 수 없어 SSD의 장점을 살릴 수 없다.

    64비트 머신에서는 SSD를 메모리로 고려해볼 수 있지만, 결국 주소 부여가 안되기 때문에 사용할 수 없다.

3. SSD 사용 수명 문제

    SSD는 최대 읽고 쓸 수 있는 횟수가 정해져 있다

    SSD를 메모리로 사용하면 사용 수명 때문에 시스템에 병목 현상이 발생할 수 있다.

    = SSD는 빈번하게 데이터를 쓸 일이 있는 작업(ex. 메모리)에 적합하지 않다.

```markdown
❓size와 size on disk의 차이

    Size는 파일의 실제 크기를 나타냅니다. 즉, 파일을 구성하는 바이트 수를 의미합니다. Size on disk는 파일이 실제로 디스크에 차지하는 공간량을 나타냅니다. 파일 시스템은 파일을 저장할 때 여러 개의 블록으로 나누어 저장합니다. 블록은 디스크의 최소 할당 단위입니다. 일반적으로 블록 크기는 4KB 또는 8KB입니다. 파일의 크기가 블록 크기의 배수로 딱 맞아 떨어지지 않으면 마지막 블록은 일부만 사용하게 됩니다.
```

```markdown
❓CPU가 조각 단위 주소로 된 체계를 직접 읽을 수 없는 이유

**1. 메모리 구조 차이:** CPU는 메모리를 페이지 단위로 관리합니다. 즉, 메모리는 작은 고정 크기의 페이지로 나뉘며 각 페이지는 고유한 페이지 테이블 항목(PTE)으로 참조됩니다. 반면에 하드 디스크 드라이브와 같은 저장 장치는 데이터를 조각 단위로 저장하며 각 조각은 고유한 조각 단위 주소를 가지고 있습니다. 이러한 구조적 차이는 CPU가 조각 단위 주소를 직접 해석하는 것을 어렵게 만듭니다.

**2. 주소 변환 과정 필요:** CPU가 데이터에 액세스하려면 먼저 가상 주소를 물리적 주소로 변환해야 합니다. 가상 주소는 프로그램에서 사용하는 주소이고 물리적 주소는 메모리에서 실제 데이터가 저장되는 위치를 나타냅니다. 페이지 테이블은 이러한 변환을 수행하는 데 사용됩니다. 조각 단위 주소 체계에서는 페이지 테이블이 없기 때문에 CPU가 가상 주소를 물리적 주소로 변환하는 데 어려움을 겪습니다.

**3. 성능 저하 가능성:** CPU가 조각 단위 주소로 된 체계를 직접 읽을 수 있다면 성능이 저하될 수 있습니다. 왜냐하면 CPU는 각 조각에 대한 PTE를 찾아야 하고 이는 추가적인 오버헤드를 발생시키기 때문입니다. 페이지 단위 주소 체계에서는 각 페이지에 대한 PTE만 필요하기 때문에 성능이 더 효율적입니다.

**4. 운영 체제의 역할:** 운영 체제는 CPU가 데이터에 액세스할 수 있도록 조각 단위 주소 체계를 추상화하는 역할을 합니다. 운영 체제는 파일 시스템 드라이버를 사용하여 데이터를 페이지로 조직하고 페이지 테이블을 유지 관리합니다. CPU는 운영 체제가 제공하는 API를 사용하여 데이터에 액세스하고, 운영 체제는 필요한 주소 변환을 수행합니다.

따라서 CPU는 조각 단위 주소로 된 체계를 직접 읽을 수 없지만 운영 체제의 도움으로 데이터에 액세스할 수 있습니다.
```
