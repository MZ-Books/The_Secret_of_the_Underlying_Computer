# 가상 메모리

컴퓨터에서 물리적인 메모리를 추상화하여 프로세스에게 할당하는 기술이다. 이를 통해 프로세스는 메모리를 독점하는 것처럼 사용할 수 있게 합니다.

> **왜 프로세스가 독립된 메모리를 가지게 해야 하나요?** 프로세스는 독립된 메모리 공간을 가지지 않는다면, 다른 프로세스의 메모리에 접근하여 문제를 일으킬 수 있습니다. 또한, 프로그래머가 다른 프로세스 사용에 대해 고려하지 않고 개발을 할 수 있게 된다는 장점이 존재합니다.

프로그램이 시작되면 메모리에 프로세스가 적재되는데, 그림과 같은 구조를 가진 가상 메모리가 적재됩니다. 물리적으로 존재하지 않지만, 그림과 같은 구조를 통해 프로세스가 마치 모든 메모리를 독점하고 있는 것처럼 착각하게 만듭니다. 32비트 시스템에서는 2^32바이트인 4GB 메모리를 독점하고 있다고 생각하게 합니다.

![alt text](../.github/image/virtual_memory_example.png)

### 실제 물리 메모리에서는?

1. 프로세스는 동일한 크기의 조각(chunk)으로 나뉘어 물리 메모리에 저장됩니다.
2. 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있습니다.

## 페이지와 페이지 테이블

`페이지` : 프로세스 주소 공간을 동일한 크기로 나눈 것

`페이지 테이블` : 각각의 프로세스는 가상 메모리와 물리 메모리 사이 관계를 가지는 페이지 테이블을 가진다.

→ 모든 프로세스는 코드 영역 `0x400000`(가상 메모리 주소)에서 프로그램을 시작한다. 서로 다른 프로세스에서 같은 가상 메모리 주소를 사용해도 괜찮은 이유는 각 프로세스 마다 페이지 테이블을 가져 실제 mapping된 물리 메모리 주소는 다를 수 있기 때문이다.

### ❓`사상은 페이지 단위로 이뤄지기 때문에 페이지 테이블이 가져야 하는 항목 수가 줄어듭니다.`

![메모리 페이지 이미지](../.github/image/memory_page.jpg)

쉽게 설명하면, 32비트 주소 공간에서는 4GB의 가상 주소 공간이 있어, 페이지 테이블도 4GB를 가져야 하지만, 4KB 페이지 단위로 조각을 나누게 되면 최대 100만개의 페이지 테이블만 가지면 되기 때문에 테이블의 크기가 줄어듭니다.
